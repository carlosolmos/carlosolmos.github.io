<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>know-how on brain dump</title>
    <link>https://carlosolmos.dev/categories/know-how/</link>
    <description>Recent content in know-how on brain dump</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 18 Dec 2022 19:10:44 -0800</lastBuildDate><atom:link href="https://carlosolmos.dev/categories/know-how/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Abandonware: evaluating the health of the libraries in your project</title>
      <link>https://carlosolmos.dev/posts/abandonware-evaluating-the-health-of-the-libraries-in-your-project/</link>
      <pubDate>Sun, 18 Dec 2022 19:10:44 -0800</pubDate>
      
      <guid>https://carlosolmos.dev/posts/abandonware-evaluating-the-health-of-the-libraries-in-your-project/</guid>
      <description>Open Source Dependencies ðŸ”—I find it very interesting how comfortable we, software engineers, have become with the notion of including thousands, and thousands, of lines of code we know nothing about in our projects. I don&amp;rsquo;t think reusing open-source libraries is bad. Quite the opposite; I am convinced that software development based on open-source software (OSS) is what allows us to move ahead in the industry at a fast pace.</description>
    </item>
    
    <item>
      <title>Node-RED and the Everactive API - Part 1</title>
      <link>https://carlosolmos.dev/posts/node-red-and-the-everactive-api-part-1/</link>
      <pubDate>Tue, 22 Nov 2022 19:01:59 -0800</pubDate>
      
      <guid>https://carlosolmos.dev/posts/node-red-and-the-everactive-api-part-1/</guid>
      <description>Node-RED is a great tool for low-code IoT programming. Its drag &amp;amp; drop interface allows you to wire hardware and software to get data flowing in no time. It&amp;rsquo;s open source and there is plenty of documentation and helpful resources around. In this article -the first of two parts- we are going to create a very simple workflow to fetch data from the Everactive API, and a public data service, and then apply a very simple thresholding function.</description>
    </item>
    
    <item>
      <title>Everactive Edge Webhooks, Fluentd, and S3</title>
      <link>https://carlosolmos.dev/posts/everactive-edge-webhooks-fluentd-and-s3/</link>
      <pubDate>Tue, 01 Nov 2022 20:22:46 -0700</pubDate>
      
      <guid>https://carlosolmos.dev/posts/everactive-edge-webhooks-fluentd-and-s3/</guid>
      <description>From Everactive&amp;rsquo;s Webhook Subscriptions to Fluentd &amp;amp; S3 ðŸ”— Disclaimer: this solution is totally overengineered. Only for learning purposes. You don&amp;rsquo;t want to use this in production, or do you?&amp;hellip;ðŸ˜œ
Everactiveâ€™s Managed Network ensures connectivity, uptime, and reliable &amp;amp; secure data transfer into our Platform. We understand that you need a steady stream of new data to transform into high-value insights to package as innovative, hyper-scale IoT applications to your end users.</description>
    </item>
    
    <item>
      <title>Everactive Edge API and Pipedream</title>
      <link>https://carlosolmos.dev/posts/everactive-edge-api-and-pipedream/</link>
      <pubDate>Sun, 09 Oct 2022 20:22:46 -0700</pubDate>
      
      <guid>https://carlosolmos.dev/posts/everactive-edge-api-and-pipedream/</guid>
      <description>The Everactive Edge RESTful API gives you direct programmatic access to the data returned by Eversensors. The API provides endpoints to retrieve data based on time ranges, and shortcuts to get the last-available reading from a particular sensor. Typically, applications will poll these endpoints to get the most up-to-date information. In this article, we are going to use Pipedream.com as a mechanism to periodically poll the API for new data and log it in a spreadsheet on Google Docs.</description>
    </item>
    
    <item>
      <title>Instrumenting applications with Prometheus</title>
      <link>https://carlosolmos.dev/posts/instrumenting-applications-with-prometheus/</link>
      <pubDate>Sat, 24 Sep 2022 22:10:52 -0700</pubDate>
      
      <guid>https://carlosolmos.dev/posts/instrumenting-applications-with-prometheus/</guid>
      <description>&amp;ldquo;What is not defined cannot be measured. What is not measured, cannot be improved. What is not improved, is always degraded&amp;rdquo;. William Thomson Kelvin
In this article, we will learn how to create custom metrics for a simple web application and use Prometheus to collect and report on them.
Site Reliability Engineering ðŸ”—This post is part of a series about Site Reliability Engineering (SRE). In the series, we will talk about different concepts,Â tools, and techniques to keep a large-scale system healthy.</description>
    </item>
    
    <item>
      <title>MQTT with RabbitMQ</title>
      <link>https://carlosolmos.dev/posts/mqtt-with-rabbitmq/</link>
      <pubDate>Mon, 12 Sep 2022 22:21:32 -0700</pubDate>
      
      <guid>https://carlosolmos.dev/posts/mqtt-with-rabbitmq/</guid>
      <description>MQTT is a widely used protocol in the IoT world.Â It is a lightweight pub/sub messaging system, with a small code footprint and minimal bandwidth requirements, which makes it ideal for connecting remote small devices. To implement the MQTT protocol you need a robust broker service to handle the connections and the messages transportation.
RabbitMQ is one of the most popular message brokers in the market. It is easy to deploy and solves all kinds of messaging requirements at small and large scales.</description>
    </item>
    
  </channel>
</rss>
